## 커넥션 관리

* TCP 를 이용하면 왜 순서가 바뀌지 않고 안전하게 전달되나요?
* 패킷 헤더에 특정 순서 정보가 있어서 전송 중간에 손실이 되더라도 모든 정보를 안전하게 조합하여 전달받을 수 있다.
<br />

* TCP 전송을 위한 패킷이 완성되는 과정이 어떻게 될까요?
* OSI 계층에서 하나의 층을 내려가면서 필요한 헤더 정보들을 덧붙여 가면서 만들어집니다.
* 그러면 가장 최종적으로 만들어진 패킷의 크기가 가장 크겠네요?
* 맞습니다.
<br />

* 커넥션을 클라이언트와 서버가 어떻게 유지할 수 있을까요?
* 유지를 한다는게 어떤걸까요?
* 서버가 클라이언트와 핸드셰이크를 맺은 상태를 말하는 겁니다.
* 만약 여러 클라이언트와 연결이 있을 때, 여러 클라이언트 간의 간섭으로 인해 통신은 어렵지 않나요?
* 로우 단계에서부터 살펴봅시다. 이 연결 정보는 어디에 저장되나요?
* 아마 메모리에 저장이 될 것 같습니다.
* 그러면 서버는 메모리에서 클라이언트 커넥션 정보를 찾아서 전송하기 때문에 커넥션 정보를 찾는데는 문제가 없다.
* 다만, 멀티 쓰레드의 구조의 경우에 간섭이 있을 것 같습니다.
* 멀티 쓰레드로 읽는 경우에 이미 로우레벨 네트워크에서 모든 패킷이 조립되어 있기 때문에 전기적 신호가 간섭될 일은 없을 것 같습니다.
<br />

* 계층간의 캡슐화는 왜 이뤄져야 할까요?
* 보안 때문에?
* 어떤 점 때문에 보안 때문이라는 걸까요?
* 위변조를 방지하기 위함이 아닐까요??
* 위변조는 TCP 계층에서 checksum 이라는 값을 통한 검증이라는 하나의 역할일 뿐이지 캡슐화에 대해서 설명하기엔 부족하지 않나 싶어요.
* 캡슐화의 측면은 유지보수 목적이 가장 큰 것 같습니다.
* 캡슐화는 문제가 터졌을 때 어느 지점에서 문제가 발생했는지 알 수 있습니다.
* 유연성도 하나의 장점인 것 같습니다. 예를 들면 보안 계층
<br />

* TCP/IP 든 OSI 계층이든 해당 단계가 어디서 이루어지는걸까요?
* [링크](https://webdir.tistory.com/262) 으로 대체
<br />

* TIME_WAIT 의 누적과 포트 고갈이 어떤 경우에 발생할 수 있을까요?
* Spring 의 RestTemplate 을 생성하여 무분별하게 통신하는 경우에 포트의 고갈로 발생할 수 있습니다.
* RestTemplate 대신에 WebClient 를 써야합니다.
<br />

* 네트워크 병목은 어떤 경우에 발생할까요?
* 가장 단순하게 생각할 때, 서버의 처리 능력이 부족할 때 발생합니다.
* 공유자원을 사용할 때, 동기화 코드를 사용할 때 발생합니다.
* 가장 좋은 방법은 공유자원을 사용하는 코드를 사용하지 않는 것 같습니다. 컴포넌트는 stateless 해야 합니다.
* concurrent 컬렉션을 활용해야 합니다.
* 락이 발생할 수 있는 곳은 상당히 다양한 것 같습니다.
<br />
