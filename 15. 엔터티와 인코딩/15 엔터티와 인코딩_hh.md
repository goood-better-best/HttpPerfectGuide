### 엔터티 본문

- **잘림 검출**
    - 메시지 잘림은 캐싱 프락시 서버에서 특히 취약함. 만약 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못했다면, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 될 것.
    - 잘린 메시지를 캐시하는 위험을 줄이기 위해, 캐싱 프락시 서버는 명시적으로 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐시하지 않음.
- **Content-Length와 지속 커넥션**
    - Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음 시작은 어디인지 알려줌.
- **콘텐츠 인코딩**
    - HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔티티 본문을 인코딩하는데, 만약 콘텐츠가 인코딩되어 있다면 Content-Length 헤더는 인코딩된 본문의 길이를 바이트 단위로 정의함.
    

### 엔터티 요약

- 엔터티 본문 데이터 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 엔터티 변경을 잡아내기 위해 체크섬으로 기본적인 검사를 할 수 있음.
- Content-MD5 헤더는 서버가 엔티티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용됨.
- 멀티파트 미디어 타입
    - MIME '멀티파트' 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내짐.
    - HTTP는 멀티파트 본문도 지원하지만, 일반적으로는 폼을 채워서 제출할 때와 문서의 일부분을 실어 나르는 범위 응답을 할 때의 두 가지 경우에만 사용함.
- 콘텐츠 인코딩 과정
    ① 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성함.
    ② 콘텐츠 인코딩 서버가 인코딩된 메시지를 생성함.
    ③ 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻음.
- 클라이언트는 각 인코딩에 Q(quality) 값을 매개변수로 더해 선호도를 나타낼 수 있음.
    - 가장 원치 않음 : 0.0, 가장 선호함 : 1.0

### 전송 인코딩과 청크 인코딩

- 안전한 전송
    - HTTP에서 전송된 메시지의 본문이 문제를 일으킬 수 있는 두 가지
        - 알 수 없는 크기
            - 몇몇 게이트웨이 애플리케이션과 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없음.
            - HTTP는 데이터에 앞서 Content-Length 헤더를 요구하기 때문에, 몇몇 서버는 데이터의 끝을 알리는 특별한 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도함.
        - 보안
            - 공용 전송 네트워크로 메시지 콘텐츠를 보내기 전에 전송 인코딩을 사용해 알아보기 어렵게 뒤섞는 방법도 있지만 이미 SSL 같은 전송 계층 보안 방식이 있기 때문에 전송 인코딩 보안은 흔하지 않음.
- Tranfer-Encoding 헤더
    - Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려줌.
    - TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용
    - HTTP/1.1은 Transfer-Encoding과 TE 헤더 필드에 전송 인코딩 값을 사용함.
- 청크 인코딩
    - 청크 인코딩은 메시지를 일정 크기의 청크 여럿으로 쪼개고, 서버는 각 청크를 순차적으로 보냄.
    - 청크 인코딩을 이용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없어짐.
    - 청크 인코딩이 전송 인코딩의 한 형태이며 본문이 아닌 메시지의 속성임.
    - 청크와 지속 커넥션
        - 지속 커넥션에서는 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아서 보내줘야 함.
        - 콘텐츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알아내는 것이 불가능할 것.
        - 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이것에 대한 해법을 제공함.

### 시간에 따라 바뀌는 인스턴스

- 같은 URL의 리소스에 대해 시간에 따라 다른 인스턴스(객체)를 응답 받을 수 있음.
- 대표적으로 범위 요청과 델타 인코딩이 있음.

### 검사기와 신선도

- 조건부 요청은 클라이언트가 서버에게 자신이 같고 있는 버전을 말해주고 검사기를 사용해 자신의 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것.
- 서버는 Expires와 Cache-Control 헤더를 통해 얼마나 오랫동안 콘텐츠를 캐시하고 신선하다고 할 수 있는지 클라이언트에게 정보를 제공함.

### 범위 요청

- 범위 요청을 이용하면, HTTP 클라이언트는 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있음.
- 서버는 클라이언트에게 자신의 범위를 받아들일 수 있는지 응답에 Accpet-Ranges 헤더를 포함시켜 알려줌.
- 범위 요청은 오직 클라이언트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있음.

### 델타 인코딩

- 만료된 웹 페이지에 대해 새 페이지 전체를 보내는 대신 변경된 부분만 서버가 보낸다면 클라이언트는더 빨리 페이지를 얻을 수 있음.
- 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적하는, HTTP 프로토콜의 확장임.
