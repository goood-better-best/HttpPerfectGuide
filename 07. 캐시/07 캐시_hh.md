## 캐시

- 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여줌.
- 네트워크 병목을 줄여줘서, 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 됨.
- 원 서버에 대한 요청을 줄여줘서, 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 됨.
- 페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여줌.

<br>

## 적중과 부적중

### **재검사 (Revalidation)**

- 원 서버의 콘텐츠가 변경될 수 있기 때문에 캐시는 사본이 최신인지 서버를 통해 때때로 점검해야함.
- If-Modified-Since 헤더
    - *재검사 적중 :* 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보냄.
    - *재검사 부적중 :* 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 HTTP 200 OK 응답을 클라이언트에게 보냄.
    - *객체 삭제 :* 서버 객체가 삭제되었다면, 서버는 404 Not Fount 응답을 돌려보내며, 캐시는 사본을 삭제함.

### 적중률

- 캐시가 요청을 처리하는 비율을 캐시 적중률 또는 문서 적중률
- 0% : 모든 요청이 캐시 부적중, 100% : 모든 요청이 캐시 적중
- 오늘날 적중률 40%면 웹 캐시로 괜찮은 편.
- **바이트 적중률**
    - 바디트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미함.
    - 문서 적중률을 개선하면 전체 대기 시간이 줄어들고, 바이트 단위 적중률의 개선은 대역폭 절약을 최적화 함.

<br>

## 캐시 토폴로지

### 개인 전용 캐시

- 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있음.
- 웹브라우저는 개인 전용 캐시를 내장하고 있으며, 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용함.

### 공용 프락시 캐시

- 캐시 프락시 서버 혹은 프락시 캐시의 공유된 프락시 서버임.
- 캐시는 자주 찾는 객체를 단 한 번만 가져와 모든 요청에 대해 공유된 사본을 제공함으로써 네트워크 트래픽을 줄임.

### 프락시 캐시 계층들

- 작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 걸러 남겨진 트래픽을 처리하도록 만드는 계층을 만드는 방식이 합리적인 경우가 많음.
- 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더크고 강력한 캐시를 사용하자는 것.

### 캐시망, 콘텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만듦.
- 어떤 부모 캐시와 통신할 것인지, 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내릴 수 있음.
- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들이 할 수 있는 일
    - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택함.
    - URL에 근거하여 특정 부모 캐시를 동적으로 선택함.
    - 부모 캐시에 가기전에, 캐시된 사본을 로컬에서 찾아봄.
    - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한
        
        인터넷 트랜짓(Internet Transit)은 허용하지 않음.
        
- 한층 더 복잡한 캐시 사이의 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 할 수 있는데, 이렇게 선택적인 피어링을 지원하는 캐시를 형제 캐시라고 부름.
- HTTP는 형제 캐시를 지원하지 않기 때문에 인터넷 캐시 프로토콜(ICP)나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장함.

<br>

## 캐시 처리 단계

- HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차 7단계
1. 요청 받기 - 캐시는 네트워크로 부터 도착한 요청 메시지를 읽음.
2. 파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출함.
3. 검색 - 캐시는 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아옴. → 로컬에 저장함.
4. 신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 서버에게 변경사항이 있는지 물어봄.
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만듦.
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줌.
7. 로깅 - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남김.

<br>

## 사본을 신선하게 유지하기

- 캐시된 사본과 서버의 문서가 항상 일치하는 것은 아님.
- 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 함.
- HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 갖고 있음.

### 문서 만료

- HTTP는 Cache-Control과 Expires라는 헤더를 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌.
- 캐시 문서가 만료되기 전에, 캐시는 서버봐의 접촉 없이 사본을 제공할 수 있음.(검사되지 않은 리소스의 제공을 거부하는 헤더가 클라이언트 요청에 들어있지 않아야 함.)

### 유효기간과 나이

- Cache-Control: max-age : 문서의 최대 나이
- Expires : 절대 유효기간을 명시하며, 만약 유효기간이 경과했다면 그 문서는 더이상 신선하지 않음을 나타냄.

### 서버 재검사

- 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줌.

### If-Modified-Since: 날짜 재검사

- IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청 본문을 보내달라고 함.
- IMS 헤더는 서버 응답 헤더의 Last-Modified 헤더와 함께 동작함.
- 캐시는 문서가 캐시된 날짜를 IMS에 보관하고, 원 서버는 제공하는 문서의 최근 변경 일시를 LM에 붙임.
- IMS와 LM을 비교해서 IMS 날짜 이후에 서버의 문서가 변경되었다면, 원 서버는 새 문서를 주고 그렇지 않다면, 304 Not Modified 응답을 돌려줄 것임.

### If-None-Match: 엔터티 태그 재검사

- 캐시는 엔터티 태그 'v2.6'인 문서를 갖고 있고, 원 서버에게 태그가 더 이상 'v2.6'이 아닌 경우에만 새 객체를 달라고 요청한다.
- 만약 서버의 엔터티 태그가 변경되었다면, 서버는 200 OK 응답으로 새 콘텐츠를 새 ETag와 함께 반환했을 것임.

### 약한 검사기와 강한 검사기

- 강한 검사기는 콘텐츠가 바뀔 때마다 바뀜.
- 약한 검사기는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경됨.
- 서버는 'W/' 접두사로 약한 검사기를 구분함.

### 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- 서버가 엔터티 태그를 반환했다면, 반드시 엔티티 태그 검사기를 사용해야 함.
- 서버가 Last-Modified 값만을 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있음.
- 엔터티 태그와 최근 변경일시가 모두 사용 가능하다면, 클라이언트는 각각을 위해 두 가지의 재검사 정책을 모두 사용해야 함.

<br>

## 캐시 제어

- HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있으며, 설정은 아래 우선순위대로 나열함.
    - Cache-Control : no-store 헤더를 응답에 첨부할 수 있음.
    - Cache-Control : no-cache 헤더를 응답에 첨부할 수 있음.
    - Cache-Control : must-revalidate 헤더를 응답에 첨부할 수 있음.
    - Cache-Control : max-age 헤더를 응답에 첨부할 수 있음.
    - Expires 날짜 헤더를 응답에 첨부할 수 있음.
    - 아무 만료 정보도 주지 않고, 캐시가 스스로 결정하게 할 수 있음.

### no-cache와 no-store 응답 헤더

- no-store : 캐시가 그 응답의 사본을 만드는 것을 금지함.
- no-cache : 로컬 캐시 저장소에 저장될 수 있지만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐.

### Max-Age 응답 헤더

```
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

- 서버로부터 온 이후로 흐른 시간이고, 초로 나타내며, s-maxage 헤더는 공유된(공용) 캐시에만 적용됨.
- 서버는 최대 나이먹음(maximum aging)을 0으로 설정함으로써, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있음.

### Expires 응답 헤더

- 실제 만료 날짜를 명시하지만, 많은 서버가 동기화되어 있지 않거나 부정확한 시계를 갖고 있기 때문에, 만료를 절대시각 대신 경과된 시간으로 표현.

### Must-Revalidate 응답 헤더

- 캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정할 수 있음. 만약 캐시가 만료 정보를 엄격하게 따르길 원한다면, 원 서버는 다음과 같은 Cache-Control을 붙일 수 있음.

```
Cache-Control: must-revalidate
```

- 이 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨을 의미함.

### 휴리스틱 만료

- LM 인자 알고리즘은 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용함.
- LM 인자 알고리즘은 캐시가 서버와 대화 했을 때와 서버가 문서의 최근 변경 일시를 말했을 때의 시간차를 계산하고, 이 차의 일부분을 취하여, 이 일부분을 캐시의 신선도 지속기간으로 사용함.

### 클라이언트 신선도 제약

- 웹브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 갖고 있음.
- 클라이언트는 Cache-Control 요청 헤더를 사용하여 만료 제약을 엄격하게 하거나 느슨하게 할 수 있음.

<br>

## 캐시 제어 설정

- 웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 제공함.

### 아파치로 HTTP 헤더 제어하기

- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공함.
- mod_headers
- mod_expires
- mod_cern_meta

<br>

## 캐시와 광고

- 캐싱이 완벽하게 동작한다면 원 서버는 HTTP 접근을 전혀 수신하지 않게 됨. 만약 접근횟수에 따라 돈을 벌고 있다면, 이는 달갑지 않은 일.
- 오늘날 캐시가 광고 시청 수를 가로채지 못하도록 모든 종류의 캐시 무력화 기법을 사용함.
- 광고를 CGI 게이트웨이를 통해 제공하며, 그들은 매 접근마다 광고 URL을 고쳐씀.
