### HTTP를 안전하게 만들기

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 통신하고 있음을 알 수 있어야 함.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 통신하고 있음을 알 수 있어야 함.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 함.
- 암호화 - 클라이언트와 서버는 제 3자의 도청에 대해 걱정 없이 서로 통신할 수 있어야 함.

### HTTPS

- HTTPS를 사용할 때, 모든 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화됨.
- HTTPS는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하며, 이 보안 계층은 안전 소켓 계층(Secure Socket Layer, SSL) 혹은 그를 계승한 전송 계층(Transport Layer Security, TLS)을 이용하여 구현됨.
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없음.

### 대칭키 암호법

- 대칭키 암호법은 인코딩을 할 때 사용하는 키가 디코딩을 할 때 사용하는 키와 같음.
- 대칭키 암호법에서의 키를 k라 하면, 발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있으며, 발송자는 평문을 k로 암호화하여 수신자에게 발송하고, 수신자는 암호문을 수신하여 k로 복호화함.

### 공개키 암호법

- 공개키 암호 방식은 두 개의 비대칭 키를 사용함.
- 하나는 메시지 인코딩을 위한 것이고, 다른 하나는 메시지를 디코딩하기 위한 것.
- 서버는 자신의 인코딩 키를 공개적으로 배포했기 때문에 메시지를 서버에게 보내고자 하는 누구나 똑같고 잘 알려진 키를 사용함으로써 키가 폭발적으로 증가하는 것을 막을 수 있음.

### 디지털 서명

- 암호 체계는 메시지 암 복호화 뿐만 아니라, 누가 메시지를 썼는지 알려주고, 그 메시지가 위조되지 않음을 증명하기 위해 메시지에 서명을 하는 데에 이용될 수 있음.
- 서명은 메시지를 작성한 저자가 누구인지 알려주며, 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있음. 체크섬은 저자의 개인 '서명'처럼 동작함.

### 디지털 인증서

- 디지털 인증서(흔히 certs라 불리는)는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고있음.
- 누구나 디지털 인증서를 만들 수 있지만, 그 모두의 인증서의 정보를 보증하고 인증서를 개인 키로 서명할 수 있는 널리 인정받는 서명 권한을 얻을 수 있는 것은 아님.

### HTTPS의 세부사항

- HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보냄.
- HTTPS의 보안 계층은, SSL과 그것의 현대적 대체품인 TLS로 구현됨.
- SSL 핸드셰이크
 
    ① 클라이언트가 암호 후보들을 보내고 인증서를 요구함.
    
    ② 서버는 선택된 암호와 인증서를 보냄.
    
    ③ 클라이언트가 비밀정보를 보낸다. 클라이언트와 서버는 키를 만듦.
    
    ④ 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해줌.
